#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Streamlit dashboard for the sales forecasting application.
"""

import os
import sys
import json
from datetime import datetime, timedelta
from pathlib import Path
import requests
import pandas as pd
import numpy as np
import streamlit as st
import plotly.express as px
import plotly.graph_objects as go
import altair as alt
from PIL import Image
# Importa√ß√µes opcionais que podem causar problemas
try:
    import jwt
except ImportError:
    import base64
    class FakeJWT:
        @staticmethod
        def decode(token, options=None):
            return {"sub": "user", "exp": 9999999999}
    jwt = FakeJWT()

from plotly.subplots import make_subplots

# Add project root to sys.path
project_root = Path(__file__).parents[2]
sys.path.insert(0, str(project_root))

# Define constants - hardcode to localhost
API_URL = "http://localhost:8002"  # Ensure API is running on port 8002
MLFLOW_URL = "http://localhost:8888"  # MLflow on port 8888

# Configure page with dark theme
st.set_page_config(
    page_title="Store Sales Forecast Dashboard",
    page_icon="üìä",
    layout="wide",
    initial_sidebar_state="expanded",
    menu_items={
        'Get Help': 'mailto:support@example.com',
        'Report a bug': 'mailto:bugs@example.com',
        'About': 'Store Sales Forecasting Dashboard - Predict and visualize sales for different stores and product families.'
    }
)

# Adicionando estilo personalizado para o banner de login
st.markdown("""
<style>
.login-banner {
    background: linear-gradient(90deg, rgba(15, 17, 23, 0.95) 0%, rgba(15, 17, 23, 0.8) 100%);
    color: white;
    padding: 20px 25px;
    border-radius: 10px;
    margin-bottom: 20px;
    border: 1px solid rgba(76, 175, 80, 0.3);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    font-weight: 500;
    display: flex;
    align-items: center;
    justify-content: space-between;
}

.login-banner-icon {
    margin-right: 10px;
    font-size: 20px;
    color: #4CAF50;
}

.login-banner-text {
    flex-grow: 1;
}

.login-banner-button {
    background-color: #4CAF50;
    color: #0e1117;
    padding: 8px 15px;
    border-radius: 5px;
    text-decoration: none;
    font-weight: bold;
    font-size: 14px;
    margin-left: 15px;
    transition: all 0.2s ease;
    border: none;
    cursor: pointer;
}

.login-banner-button:hover {
    background-color: #3e8e41;
    box-shadow: 0 2px 8px rgba(76, 175, 80, 0.5);
}
</style>
""", unsafe_allow_html=True)

# Adicionar o estilo personalizado para o banner superior
st.markdown("""
<style>
.custom-top-banner {
    background: linear-gradient(90deg, rgba(76, 175, 80, 0.15) 0%, rgba(76, 175, 80, 0.2) 100%);
    color: white;
    padding: 15px 20px;
    border-radius: 5px;
    margin-bottom: 20px;
    border-left: 4px solid #4CAF50;
    font-weight: 500;
    display: flex;
    align-items: center;
}

.banner-icon {
    color: #4CAF50;
    font-size: 24px;
    margin-right: 10px;
}

.banner-text {
    color: #fafafa;
    font-size: 16px;
}
</style>
""", unsafe_allow_html=True)

# Para debug - se a sess√£o existe mas est√° vazia
if "token" not in st.session_state:
    st.session_state.token = None
    st.session_state.token_type = None
    st.session_state.user_info = None

# Inicializar estado para controle de autentica√ß√£o
if "authenticated" not in st.session_state:
    st.session_state.authenticated = False

# Force dark mode
st.markdown("""
<style>
:root {
    --background-color: #121212;
    --secondary-background-color: #1e1e1e;
    --primary-color: #4CAF50;
    --secondary-color: #FF4B4B;
    --accent-color: #4CAF50;
    --success-color: #4CAF50;
    --text-color: #e0e0e0;
    color-scheme: dark;
}

/* Override Streamlit default styles to force dark theme */
.stApp {
    background-color: #121212 !important;
    color: #e0e0e0 !important;
}

.st-bq {
    background-color: #1e1e1e !important;
}

/* Melhorar o estilo do banner de alerta no topo */
[data-baseweb="notification"] {
    background-color: rgba(76, 175, 80, 0.15) !important;
    border-color: #4CAF50 !important;
    color: #e0e0e0 !important;
}

[data-baseweb="notification"] [data-testid="stMarkdownContainer"] p {
    color: #e0e0e0 !important;
}

.stAlert {
    background-color: rgba(76, 175, 80, 0.15) !important;
    color: #e0e0e0 !important;
    border-radius: 8px !important;
    border-left: 3px solid #4CAF50 !important;
}

/* Corrigir o banner amarelo */
div[data-testid="stNotification"] {
    background-color: rgba(76, 175, 80, 0.15) !important;
    border-color: #4CAF50 !important;
    color: #e0e0e0 !important;
}

.stTextInput input, .stNumberInput input, .stDateInput input {
    background-color: #2a2a2a !important;
    color: #e0e0e0 !important;
    border: 1px solid #333 !important;
}

.stSelectbox select, .stMultiSelect select, .stDateInput, .stTimeInput {
    background-color: #2a2a2a !important;
    color: #e0e0e0 !important;
    border: 1px solid #333 !important;
}

/* Buttons styling */
.stButton > button {
    background-color: #4CAF50 !important;
    color: white !important;
    border: none !important;
    border-radius: 4px !important;
    font-weight: 600 !important;
    transition: all 0.3s !important;
}

.stButton > button:hover {
    background-color: #3e8e41 !important;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3) !important;
    transform: translateY(-2px) !important;
}

/* Metric container styling */
[data-testid="stMetric"] {
    background-color: #1e1e1e;
    border-radius: 8px;
    padding: 15px;
    box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
    border: 1px solid #333;
}

[data-testid="stMetric"] > div {
    color: #4CAF50 !important;
    font-weight: 600;
}

[data-testid="stMetric"] [data-testid="stMetricLabel"] {
    color: #aaa !important;
}

/* Card styling for containers */
[data-testid="stExpander"] {
    background-color: #1e1e1e !important;
    border-radius: 8px !important;
    border: 1px solid #333 !important;
    box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3) !important;
}

/* Making charts have dark background */
[data-testid="stPlotlyChart"] > div {
    background-color: #1e1e1e !important;
    border-radius: 8px !important;
    padding: 15px !important;
    border: 1px solid #333 !important;
}
</style>
""")

# Authentication functions
def login(username, password):
    """
    Login to the API and get a JWT token.
    """
    try:
        # Debug log
        print(f"Attempting login with {username} to API at {API_URL}/token")
        
        # Use the /token endpoint with form data as expected by OAuth2
        response = requests.post(
            f"{API_URL}/token",
            data={
                "username": username,
                "password": password
            },
            headers={"Content-Type": "application/x-www-form-urlencoded"}
        )
        
        # Detailed response log
        print(f"Login status code: {response.status_code}")
        print(f"Login response headers: {response.headers}")
        print(f"Login response (first 100 chars): {response.text[:100] if response.text else ''}")
        
        if response.status_code == 200:
            token_data = response.json()
            print(f"Login successful! Token received (first 20 chars): {token_data.get('access_token', '')[:20]}")
            st.session_state.authenticated = True
            return token_data
        else:
            print(f"Login failed: {response.text}")
            st.error(f"Login failed: {response.text}")
            return None
    except Exception as e:
        print(f"Error connecting to API: {str(e)}")
        st.error(f"Error connecting to API: {str(e)}")
        return None

def decode_token(token):
    """
    Decode the JWT token to get user info.
    """
    try:
        # This is just for display, no verification needed
        return jwt.decode(token, options={"verify_signature": False})
    except Exception as e:
        print(f"Erro decodificando token: {str(e)}")
        st.error(f"Error decoding token: {str(e)}")
        return {}

# Helper function to check authentication
def ensure_authenticated():
    """Verifies if the token is present and still valid."""
    if not st.session_state.token:
        return False
        
    # Verify token is working by making a test request
    try:
        headers = {"Authorization": f"Bearer {st.session_state.token}"}
        response = requests.get(f"{API_URL}/users/me", headers=headers)
        if response.status_code == 200:
            print("Token verified and valid")
            return True
        else:
            print(f"Invalid token, status: {response.status_code}, response: {response.text[:100]}")
            # If token expired, clear authentication state
            if response.status_code == 401:
                st.session_state.token = None
                st.session_state.token_type = None
                st.session_state.authenticated = False
            return False
    except Exception as e:
        print(f"Error verifying token: {str(e)}")
        return False

# API interaction functions
def get_prediction(token, store_nbr, family, onpromotion, date):
    """
    Get a sales prediction from the API.
    """
    try:
        # If store_nbr is a string like "Store data" or "Store 1", extract the number
        if isinstance(store_nbr, str):
            if store_nbr.lower().startswith("store"):
                parts = store_nbr.split()
                if len(parts) > 1:
                    try:
                        store_nbr = int(parts[1])
                    except ValueError:
                        # Default to store 1 if conversion fails
                        store_nbr = 1
            else:
                # Try to convert directly, or use default
                try:
                    store_nbr = int(store_nbr)
                except ValueError:
                    store_nbr = 1
        
        headers = {"Authorization": f"Bearer {token}"}
        response = requests.get(
            f"{API_URL}/predict_single",
            params={
                "store_nbr": store_nbr,
                "family": family,
                "onpromotion": onpromotion,
                "date": date
            },
            headers=headers
        )
        
        if response.status_code == 200:
            result = response.json()
            # Ensure we always have the 'prediction' key
            if 'predicted_sales' in result and 'prediction' not in result:
                result['prediction'] = result['predicted_sales']
            return result
        else:
            error_details = ""
            try:
                error_data = response.json()
                if "detail" in error_data:
                    error_details = error_data["detail"]
            except:
                error_details = response.text
                
            st.error(f"Prediction failed: {error_details}")
            return None
    except Exception as e:
        st.error(f"Error connecting to API: {str(e)}")
        return None

def get_explanation(token, prediction_id, store_nbr, family, onpromotion, date):
    """
    Get an explanation for a prediction from the API.
    """
    try:
        headers = {"Authorization": f"Bearer {token}"}
        response = requests.get(
            f"{API_URL}/explain/{prediction_id}",
            params={
                "store_nbr": store_nbr,
                "family": family,
                "onpromotion": onpromotion,
                "date": date
            },
            headers=headers
        )
        
        if response.status_code == 200:
            return response.json()
        else:
            st.error(f"Explanation failed: {response.json().get('detail', 'Unknown error')}")
            return None
    except Exception as e:
        st.error(f"Error connecting to API: {str(e)}")
        return None

def get_health():
    """
    Get API health status.
    """
    try:
        response = requests.get(f"{API_URL}/health")
        if response.status_code == 200:
            return response.json()
        else:
            return {"status": "error", "message": f"API returned status code {response.status_code}"}
    except Exception as e:
        return {"status": "error", "message": f"Error connecting to API: {str(e)}"}

def get_stores():
    """
    Get a list of stores from the API.
    """
    try:
        # Get stores from API
        response = requests.get(f"{API_URL}/stores")
        if response.status_code == 200:
            data = response.json()
            
            # Check if we have the data in a nested structure
            if isinstance(data, dict) and "data" in data:
                stores_list = data["data"]
            else:
                stores_list = data
                
            # Ensure we have a list of integers
            if isinstance(stores_list, list):
                # Format each store number
                return [f"Store {int(store)}" for store in stores_list if str(store).isdigit()]
            
        # Fallback stores if API call failed or returned invalid data
        return [f"Store {i}" for i in range(1, 11)]
    except Exception as e:
        # Log the error but don't show to user
        print(f"Error fetching stores: {str(e)}")
        # Fallback stores if API connection fails
        return [f"Store {i}" for i in range(1, 11)]

def get_families():
    """
    Get a list of product families from the API.
    """
    try:
        # Get families from API
        response = requests.get(f"{API_URL}/families")
        if response.status_code == 200:
            data = response.json()
            
            # Check if we have the data in a nested structure
            if isinstance(data, dict) and "data" in data:
                families_list = data["data"]
            else:
                families_list = data
                
            # Ensure we have a valid list of strings
            if isinstance(families_list, list) and all(isinstance(f, str) for f in families_list):
                return [f for f in families_list if f and not f.lower() == "data"]
            
        # Default families if API returns invalid data
        return ["PRODUCE", "GROCERY I", "DAIRY", "BEVERAGES", "BREAD/BAKERY"]
    except Exception as e:
        # Log the error but don't show to user
        print(f"Error fetching product families: {str(e)}")
        # Default families if API connection fails
        return ["PRODUCE", "GROCERY I", "DAIRY", "BEVERAGES", "BREAD/BAKERY"]

def get_sales_data(token, store_nbr, family, days=90):
    """
    Get sales data from the API.
    """
    try:
        headers = {"Authorization": f"Bearer {token}"}
        response = requests.get(
            f"{API_URL}/sales_history",
            params={
                "store_nbr": store_nbr,
                "family": family,
                "days": days
            },
            headers=headers
        )
        
        if response.status_code == 200:
            response_data = response.json()
            
            # Handle both old and new response formats
            if isinstance(response_data, dict) and "data" in response_data:
                # New format with metadata
                data = response_data["data"]
                
                # Show warning if mock data
                if response_data.get("is_mock_data", False):
                    message = response_data.get("message", "WARNING: Using simulated sales data")
                    st.warning(message, icon="‚ö†Ô∏è")
            else:
                # Old format (direct array)
                data = response_data
            
            return pd.DataFrame(data)
        else:
            st.error(f"Failed to fetch sales data: {response.status_code} - {response.text}")
            return pd.DataFrame(columns=['date', 'sales'])
    except Exception as e:
        st.error(f"Error fetching sales data: {str(e)}")
        return pd.DataFrame(columns=['date', 'sales'])

def get_metric_summary(token):
    """
    Get sales metrics summary from the API.
    """
    try:
        # Detailed debug log
        print(f"Calling metrics_summary with token: {token[:20] if token else 'None'}")
        
        # Ensure we don't send a null token
        if not token:
            print("ERROR: Attempting to call metrics_summary without token")
            return None
            
        # Correct formatting of authentication header
        headers = {"Authorization": f"Bearer {token}"}
        print(f"Headers: {headers}")
        
        # Make the request
        response = requests.get(
            f"{API_URL}/metrics_summary",
            headers=headers
        )
        
        # Detailed response log
        print(f"Status code: {response.status_code}")
        if response.status_code != 200:
            print(f"Error response: {response.text[:200]}") 
        
        if response.status_code == 200:
            data = response.json()
            print(f"Data received successfully: {str(data)[:100]}...")
            
            # Check if data is mock and show warning
            if data.get("is_mock_data", False):
                message = data.get("message", "WARNING: Using simulated data")
                st.warning(message, icon="‚ö†Ô∏è")
                
            return data
        elif response.status_code == 401:
            # If unauthorized, try to renew token
            print("Invalid or expired token. Logging out for reauthentication.")
            # Indicate to user they need to log in again
            st.error("Your session has expired. Please login again.")
            return None
        else:
            st.error(f"Failed to fetch metrics: {response.status_code} - {response.text}")
            return None
    except Exception as e:
        print(f"Error fetching metrics: {str(e)}")
        st.error(f"Error fetching metrics: {str(e)}")
        return None

def get_model_metrics(token, model_name):
    """
    Get the performance metrics for a specific model from the API.
    """
    try:
        # Prepare request headers with authentication
        headers = {"Authorization": f"Bearer {token}"}
        
        # Make the API request
        response = requests.get(
            f"{API_URL}/model_metrics",
            params={"model_name": model_name},
            headers=headers
        )
        
        if response.status_code == 200:
            return response.json()
        else:
            st.error(f"Failed to fetch model metrics: {response.status_code} - {response.text}")
            return None
    except Exception as e:
        st.error(f"Error fetching model metrics: {str(e)}")
        return None

def get_feature_importance(token, model_name):
    """
    Get the feature importance data for a specific model from the API.
    """
    try:
        # Prepare request headers with authentication
        headers = {"Authorization": f"Bearer {token}"}
        
        # Make the API request
        response = requests.get(
            f"{API_URL}/feature_importance",
            params={"model_name": model_name},
            headers=headers
        )
        
        if response.status_code == 200:
            return response.json()
        else:
            st.error(f"Failed to fetch feature importance: {response.status_code} - {response.text}")
            return None
    except Exception as e:
        st.error(f"Error fetching feature importance: {str(e)}")
        return None

def get_model_drift(token, model_name, days=30):
    """
    Get the model drift data for a specific model from the API.
    """
    try:
        # Prepare request headers with authentication
        headers = {"Authorization": f"Bearer {token}"}
        
        # Make the API request
        response = requests.get(
            f"{API_URL}/model_drift",
            params={"model_name": model_name, "days": days},
            headers=headers
        )
        
        if response.status_code == 200:
            return response.json()
        else:
            st.error(f"Failed to fetch model drift: {response.status_code} - {response.text}")
            return None
    except Exception as e:
        st.error(f"Error fetching model drift: {str(e)}")
        return None

# UI components
def render_sidebar():
    """
    Render the sidebar elements.
    """
    st.sidebar.title("Navigation")
    
    # DEBUG TOKEN STATE - debug mode only
    debug_mode = False
    if debug_mode:
        st.sidebar.subheader("Token Status")
        if st.session_state.get("token"):
            st.sidebar.success("‚úÖ Token present")
            token_str = st.session_state.token
            if len(token_str) > 50:
                token_str = f"{token_str[:25]}...{token_str[-25:]}"
            st.sidebar.code(token_str, language="text")
        else:
            st.sidebar.error("‚ùå Token missing")
    
    # Check for authentication
    if not st.session_state.get("token") or not st.session_state.authenticated:
        # Enhanced login section
        st.sidebar.markdown("""
        <div style="background-color: #1E1E1E; padding: 15px; border-radius: 10px; border-left: 3px solid #4fd1c5;">
            <h3 style="color: #4fd1c5; margin-top: 0;">Login</h3>
            <p style="font-size: 0.9em; opacity: 0.8;">Please enter your credentials to access the dashboard.</p>
        </div>
        """, unsafe_allow_html=True)
        
        with st.sidebar.form("login_form", clear_on_submit=False):
            # Styled username field
            st.markdown('<p style="margin-bottom: 5px; font-weight: bold; color: #cccccc;">Username</p>', unsafe_allow_html=True)
            username = st.text_input("", placeholder="Enter username", key="username_input", label_visibility="collapsed")
            
            # Styled password field
            st.markdown('<p style="margin-bottom: 5px; font-weight: bold; color: #cccccc;">Password</p>', unsafe_allow_html=True)
            password = st.text_input("", type="password", placeholder="Enter password", key="password_input", label_visibility="collapsed")
            
            # Add some space
            st.markdown("<br>", unsafe_allow_html=True)
            
            # Styled login button
            submit = st.form_submit_button("Sign In", use_container_width=True)
            
            if submit:
                if username and password:
                    # Log before attempting login
                    print(f"Attempting login with user: {username}")
                    
                    with st.spinner("Authenticating..."):
                        auth_response = login(username, password)
                        if auth_response:
                            # Log before saving token
                            print(f"Login successful. Saving token...")
                            
                            st.session_state.token = auth_response["access_token"]
                            st.session_state.token_type = auth_response["token_type"]
                            st.session_state.user_info = decode_token(auth_response["access_token"])
                            st.session_state.authenticated = True
                            
                            # Log after saving token
                            print(f"Token saved: {st.session_state.token[:20]}...")
                            
                            st.success("Login successful!")
                            st.rerun()
                        else:
                            st.error("Login failed. Please check your credentials.")
                else:
                    st.error("Please enter both username and password.")
        
        # Demo credentials with improved styling
        st.sidebar.markdown("""
        <div style="background-color: #1E1E1E; padding: 15px; border-radius: 10px; margin-top: 20px; border-left: 3px solid #FFD166;">
            <h4 style="color: #FFD166; margin-top: 0;">Demo Credentials</h4>
            <p style="font-size: 0.9em; margin-bottom: 5px;"><span style="color: #FFD166; font-weight: bold;">Username:</span> johndoe</p>
            <p style="font-size: 0.9em; margin-bottom: 0;"><span style="color: #FFD166; font-weight: bold;">Password:</span> secret</p>
            <hr style="border-color: #333333; margin: 10px 0;">
            <p style="font-size: 0.9em; margin-bottom: 5px;"><span style="color: #FFD166; font-weight: bold;">Username:</span> admin</p>
            <p style="font-size: 0.9em; margin-bottom: 0;"><span style="color: #FFD166; font-weight: bold;">Password:</span> admin</p>
        </div>
        """, unsafe_allow_html=True)
        
    else:
        # Verify token - if expired, force logout
        is_valid = ensure_authenticated()
        if not is_valid:
            print("Invalid token detected. Forcing logout...")
            st.sidebar.error("Your session has expired. Please login again.")
            for key in list(st.session_state.keys()):
                del st.session_state[key]
            st.rerun()
            
        # User info with better styling
        st.sidebar.markdown("""
        <div style="background-color: #1E1E1E; padding: 15px; border-radius: 10px; margin-bottom: 20px; border-left: 3px solid #06D6A0;">
            <h4 style="color: #06D6A0; margin-top: 0;">User Profile</h4>
        """, unsafe_allow_html=True)
        
        user_info = st.session_state.user_info
        st.sidebar.markdown(f"**Username:** {user_info.get('sub', 'Unknown')}")
        
        scopes = user_info.get("scopes", [])
        if scopes:
            st.sidebar.markdown("**Permissions:**")
            for scope in scopes:
                st.sidebar.markdown(f"- {scope}")
                
        st.sidebar.markdown("</div>", unsafe_allow_html=True)
        
        # Page navigation with improved styling
        st.sidebar.markdown("""
        <div style="background-color: #1E1E1E; padding: 15px; border-radius: 10px; margin-bottom: 20px; border-left: 3px solid #4fd1c5;">
            <h4 style="color: #4fd1c5; margin-top: 0;">Navigation</h4>
        </div>
        """, unsafe_allow_html=True)
        
        page = st.sidebar.radio(
            "Select Page",
            ["Dashboard", "Predictions", "Model Insights", "Settings"],
            key="page_selector"
        )
        st.session_state.page = page
        
        # Logout button with improved styling
        st.sidebar.markdown("<br>", unsafe_allow_html=True)
        if st.sidebar.button("Logout", key="logout_button", use_container_width=True):
            print("Logout requested by user. Clearing session state...")
            for key in list(st.session_state.keys()):
                del st.session_state[key]
            st.rerun()
    
    # API Status with improved styling
    st.sidebar.markdown("""
    <div style="background-color: #1E1E1E; padding: 15px; border-radius: 10px; margin-top: 20px; border-left: 3px solid #FFD166;">
        <h4 style="color: #FFD166; margin-top: 0;">System Status</h4>
    """, unsafe_allow_html=True)
    
    health = get_health()
    if health["status"] == "healthy":
        st.sidebar.success("‚úÖ API is online and healthy")
    else:
        st.sidebar.error(f"‚ùå API is not available: {health.get('message', 'Unknown error')}")
        
    st.sidebar.markdown("</div>", unsafe_allow_html=True)
    
    # Links with improved styling
    st.sidebar.markdown("""
    <div style="background-color: #1E1E1E; padding: 15px; border-radius: 10px; margin-top: 20px; border-left: 3px solid #FF4B4B;">
        <h4 style="color: #FF4B4B; margin-top: 0;">Resources</h4>
        <p style="margin-bottom: 5px;"><a href="%s" style="color: #4fd1c5; text-decoration: none;">üìä MLflow Dashboard</a></p>
        <p style="margin-bottom: 0;"><a href="%s/docs" style="color: #4fd1c5; text-decoration: none;">üìö API Documentation</a></p>
    </div>
    """ % (MLFLOW_URL, API_URL), unsafe_allow_html=True)

def display_sales_history(store_nbr, family, days):
    try:
        # Get sales history data from API
        headers = {"Authorization": f"Bearer {st.session_state.token}"}
        response = requests.get(
            f"{API_URL}/sales_history?store_nbr={store_nbr}&family={family}&days={days}",
            headers=headers
        )
        
        if response.status_code != 200:
            st.warning(f"No sales history data available for Store {store_nbr}, {family}")
            return
        
        # Get the data from the response
        try:
            history_data = response.json()
        except Exception as e:
            st.error(f"Error parsing response data: {str(e)}")
            return
        
        # Check if the data is from the API's 'data' field (new format)
        if isinstance(history_data, dict) and 'data' in history_data:
            # New format with metadata
            data = history_data['data']
            is_mock = history_data.get('is_mock_data', False)
            message = history_data.get('message', None)
        else:
            # Old format (just a list of records)
            data = history_data
            is_mock = False
            message = None
        
        if not data or not isinstance(data, list) or len(data) == 0:
            st.warning(f"No sales history data available for Store {store_nbr}, {family}")
            return
        
        # Create DataFrame for plotting, handling potential data issues
        valid_records = []
        for record in data:
            try:
                # Validate and convert data
                if not isinstance(record, dict):
                    continue
                    
                date_val = record.get('date')
                sales_val = record.get('sales')
                is_promotion = record.get('is_promotion', 0)
                
                if date_val is None or sales_val is None:
                    continue
                    
                # Try to convert sales to float
                try:
                    sales_val = float(sales_val)
                except (ValueError, TypeError):
                    # Skip if sales cannot be converted to float
                    continue
                
                # Add to valid records
                valid_records.append({
                    'date': date_val,
                    'sales': sales_val,
                    'is_promotion': int(is_promotion) if is_promotion is not None else 0
                })
            except Exception:
                # Skip any record that causes errors
                continue
        
        if not valid_records:
            st.warning(f"No valid sales history data available for Store {store_nbr}, {family}")
            return
            
        # Create dataframe from valid records
        df = pd.DataFrame(valid_records)
        
        # Try to convert date column to datetime
        try:
            df['date'] = pd.to_datetime(df['date'])
            # Sort by date
            df = df.sort_values('date')
        except Exception as date_error:
            st.warning(f"Error processing date values: {str(date_error)}")
            # If date conversion fails, we can still try to display the data
        
        # Only show warning if explicitly marked as mock data and has a message
        if is_mock and message:
            st.warning(message)
        
        # Display the sales trend chart
        title = f"Sales Trend for Store {store_nbr} - {family}"
        st.subheader(title)
        
        # Create Plotly figure with promotions
        fig = make_subplots()
        
        # Add sales line
        fig.add_trace(
            go.Scatter(
                x=df['date'], 
                y=df['sales'], 
                mode='lines', 
                name='Sales',
                line=dict(color='#3366CC', width=2)
            )
        )
        
        # Add markers for promotions if available
        if 'is_promotion' in df.columns:
            # Filter only dates with promotions
            promo_df = df[df['is_promotion'] == 1]
            if not promo_df.empty:
                fig.add_trace(
                    go.Scatter(
                        x=promo_df['date'], 
                        y=promo_df['sales'], 
                        mode='markers', 
                        name='Promotions',
                        marker=dict(color='red', size=8, symbol='circle')
                    )
                )
        
        # Update layout
        fig.update_layout(
            title=None,
            xaxis_title='Date',
            yaxis_title='Sales ($)',
            template='plotly_dark',
            height=400,
            margin=dict(l=10, r=10, t=30, b=10),
            legend=dict(
                orientation="h",
                yanchor="bottom",
                y=1.02,
                xanchor="right",
                x=1
            )
        )
        
        st.plotly_chart(fig, use_container_width=True)
        
    except Exception as e:
        st.error(f"Error displaying sales history: {str(e)}")

def display_dashboard():
    st.header("Store Sales Forecast Dashboard")
    
    # Verify authentication before trying to load metrics
    if not st.session_state.get("token") or not st.session_state.authenticated:
        st.warning("Please login to view the complete dashboard.")
        return
    
    # Display KPIs
    col1, col2, col3, col4 = st.columns(4)
    
    try:
        # Get metrics from API
        print("Loading metrics from dashboard...")
        
        # Create proper authorization header with token
        auth_token = st.session_state.token
        headers = {
            "Authorization": f"Bearer {auth_token}"
        }
        print(f"Using auth header: {headers}")
        
        # Make direct API call - avoid using get_metric_summary helper for now
        api_response = requests.get(f"{API_URL}/metrics_summary", headers=headers)
        
        # Log response for debugging
        print(f"API response status: {api_response.status_code}")
        print(f"API response: {api_response.text[:200]}")
        
        if api_response.status_code == 200:
            metrics = api_response.json()
            
            with col1:
                st.metric("Total Stores", str(metrics.get("total_stores", "N/A")))
                
            with col2:
                total_families = metrics.get("total_families", "N/A")
                if isinstance(total_families, (int, float)):
                    total_families_str = f"{total_families} families"
                else:
                    total_families_str = "N/A"
                st.metric("Total Products", total_families_str)
                
            with col3:
                avg_sales = metrics.get("avg_sales", 0)
                if isinstance(avg_sales, (int, float)):
                    formatted_avg = f"${avg_sales:.2f}"
                else:
                    formatted_avg = "N/A"
                st.metric("Average Sales", formatted_avg)
                
            with col4:
                accuracy = metrics.get("forecast_accuracy", 0)
                if isinstance(accuracy, (int, float)):
                    accuracy_str = f"{accuracy:.1f}%"
                else:
                    accuracy_str = "N/A"
                st.metric("Forecast Accuracy", accuracy_str)
        elif api_response.status_code == 401:
            # Authentication error - clear session and show error
            st.error("Authentication failed. Please login again.")
            print("Authentication error from API. Token may be invalid.")
            # Use fallback values
            with col1:
                st.metric("Total Stores", "N/A")
            with col2:
                st.metric("Total Products", "N/A")
            with col3:
                st.metric("Average Sales", "N/A")
            with col4:
                st.metric("Forecast Accuracy", "N/A")
        else:
            # Problems with token or API - show default values
            print(f"Error loading metrics - API returned {api_response.status_code}")
            with col1:
                st.metric("Total Stores", "N/A")
            with col2:
                st.metric("Total Products", "N/A")
            with col3:
                st.metric("Average Sales", "N/A")
            with col4:
                st.metric("Forecast Accuracy", "N/A")
    except Exception as e:
        print(f"Error loading metrics: {str(e)}")
        st.error(f"Error loading metrics: {str(e)}")
        # Use fallback values if API call fails
        with col1:
            st.metric("Total Stores", "N/A")
        with col2:
            st.metric("Total Products", "N/A")
        with col3:
            st.metric("Average Sales", "N/A")
        with col4:
            st.metric("Forecast Accuracy", "N/A")
    
    # Dashboard Filters
    st.subheader("Filters")
    col1, col2, col3 = st.columns(3)
    
    with col1:
        st.markdown("Store")
        # Get store options and filter out invalid ones
        store_options = get_stores()
        store_options = [s for s in store_options if not s.lower().endswith("data")]
        if not store_options:
            store_options = [f"Store {i}" for i in range(1, 11)]
        
        store_filter = st.selectbox("", options=store_options, index=0, key="dashboard_store")
    
    with col2:
        st.markdown("Product Family")
        # Get family options and filter out invalid ones
        family_options = get_families()
        family_options = [f for f in family_options if f.lower() != "data"]
        if not family_options:
            family_options = ["PRODUCE", "GROCERY I", "DAIRY", "BEVERAGES", "BREAD/BAKERY"]
            
        family_filter = st.selectbox("", options=family_options, index=0, key="dashboard_family")
    
    with col3:
        st.markdown("Days to Display")
        days_filter = st.slider("", min_value=30, max_value=365, value=90)
    
    # Extract store number from formatted string
    try:
        # Try to extract a number from the store string
        store_parts = store_filter.split()
        if len(store_parts) > 1 and store_parts[0].lower() == "store":
            try:
                store_nbr = int(store_parts[1])
            except ValueError:
                # If conversion fails, use a default value
                store_nbr = 1
        else:
            # Default if the format is unexpected
            store_nbr = 1
    except Exception:
        # Fallback value
        store_nbr = 1
    
    # Display visualization based on filters
    display_sales_history(store_nbr, family_filter, days_filter)
    
    # Show additional metrics/charts
    try:
        # Get store comparison data
        headers = {"Authorization": f"Bearer {st.session_state.token}"}
        response = requests.get(f"{API_URL}/store_comparison", headers=headers)
        
        if response.status_code == 200:
            store_data = response.json()
            
            if store_data:
                st.subheader("Sales Trends")
                
                # Handle potential data issues
                valid_data = []
                for item in store_data:
                    try:
                        # Ensure all required fields are present and of the correct type
                        store_name = item.get('store', f"Store {len(valid_data)+1}")
                        sales_value = float(item.get('sales', 0))
                        forecast_accuracy = float(item.get('forecast_accuracy', 0.8))
                        
                        valid_data.append({
                            'store': store_name,
                            'sales': sales_value,
                            'forecast_accuracy': forecast_accuracy
                        })
                    except (ValueError, TypeError):
                        # Skip invalid entries
                        continue
                
                if valid_data:
                    # Create DataFrame from valid data
                    df_stores = pd.DataFrame(valid_data)
                    
                    # Sort by sales in descending order
                    df_stores = df_stores.sort_values(by='sales', ascending=False)
                    
                    # Create comparison bar chart
                    fig = px.bar(
                        df_stores, 
                        x='store', 
                        y='sales',
                        color='forecast_accuracy', 
                        color_continuous_scale='Viridis',
                        labels={'sales': 'Total Sales ($)', 'store': 'Store', 'forecast_accuracy': 'Forecast Accuracy'},
                        title=f"Sales Trend for Store {store_nbr} - {family_filter}",
                    )
                    
                    # Update layout for dark theme
                    fig.update_layout(
                        template='plotly_dark',
                        coloraxis_colorbar=dict(title="Accuracy"),
                        title=None,
                        height=400,
                        margin=dict(l=10, r=10, t=30, b=10)
                    )
                    
                    st.plotly_chart(fig, use_container_width=True)
                else:
                    st.warning("No valid data available for store comparison chart")
            else:
                st.warning("No data available for store comparison")
        else:
            st.warning(f"Failed to fetch store comparison data: {response.status_code}")
    except Exception as e:
        st.error(f"Error loading store comparison: {str(e)}")

def render_predictions():
    """
    Render the predictions page using real data from the API.
    """
    st.title("Sales Predictions")
    
    # Adicionar CSS para esta p√°gina espec√≠fica
    st.markdown("""
    <style>
    .prediction-card {
        background-color: #1E1E1E;
        border-radius: 10px;
        padding: 20px;
        margin-bottom: 20px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        border-left: 3px solid #4fd1c5;
        transition: all 0.3s ease;
    }
    
    .prediction-card:hover {
        box-shadow: 0 8px 20px rgba(0,0,0,0.25);
        transform: translateY(-2px);
    }
    
    .prediction-header {
        display: flex;
        align-items: center;
        margin-bottom: 15px;
        border-bottom: 1px solid #333;
        padding-bottom: 10px;
    }
    
    .prediction-results {
        background-color: #262730;
        border-radius: 8px;
        padding: 15px;
        margin-top: 15px;
        border-left: 3px solid #FFD166;
    }
    
    .real-prediction {
        background-color: rgba(6, 214, 160, 0.1);
        border: 1px solid rgba(6, 214, 160, 0.3);
        border-radius: 8px;
        padding: 15px;
    }
    
    .form-container {
        background-color: #262730;
        border-radius: 10px;
        padding: 20px;
        margin-bottom: 20px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    }
    
    .animated-bg {
        background: linear-gradient(270deg, #1E1E1E, #262730);
        background-size: 400% 400%;
        animation: gradient 8s ease infinite;
    }
    
    @keyframes gradient {
        0% {background-position: 0% 50%}
        50% {background-position: 100% 50%}
        100% {background-position: 0% 50%}
    }
    </style>
    """, unsafe_allow_html=True)
    
    # Descri√ß√£o mais atraente
    st.markdown("""
    <div class="prediction-card animated-bg">
        <div class="prediction-header">
            <h3 style="color: #4fd1c5; margin: 0; flex-grow: 1;">Advanced Sales Forecasting</h3>
            <span style="background-color: rgba(79, 209, 197, 0.2); color: #4fd1c5; padding: 3px 8px; border-radius: 12px; font-size: 12px; font-weight: bold;">ML POWERED</span>
        </div>
        <p>Use our state-of-the-art machine learning models to predict future sales for specific stores and product families. Our models achieve over 80% accuracy and can help optimize inventory management and marketing strategies.</p>
    </div>
    """, unsafe_allow_html=True)
    
    # Check API health before allowing predictions
    health = get_health()
    if health["status"] != "healthy":
        st.error(f"API is not available: {health.get('message', 'Unknown error')}")
        st.warning("Please make sure the API is running before making predictions.")
        st.stop()
    
    # Get stores and families from API
    stores = get_stores()
    families = get_families()
    
    # Filter out invalid options
    stores = [s for s in stores if not s.lower().endswith("data")]
    families = [f for f in families if f.lower() != "data"]
    
    if not stores:
        # Ensure we have at least some valid stores
        stores = [f"Store {i}" for i in range(1, 11)]
    
    if not families:
        # Ensure we have at least some valid families
        families = ["PRODUCE", "GROCERY I", "DAIRY", "BEVERAGES", "BREAD/BAKERY"]
    
    # Show advanced options
    with st.expander("Advanced Options"):
        enable_debug = st.checkbox("Show Debug Information", value=False)
    
    # Form for predictions within card
    st.markdown("""
    <div class="form-container">
        <h4 style="color: #FFD166; margin-top: 0; margin-bottom: 15px;">Prediction Parameters</h4>
    </div>
    """, unsafe_allow_html=True)
    
    with st.form("prediction_form"):
        col1, col2, col3 = st.columns(3)
        
        # Default values we know that work
        default_store_index = 0
        default_family_index = 0
        
        # Try to find default values in the stores and families lists
        if stores and families:
            # Look for store 1 in the stores list
            for i, store in enumerate(stores):
                if store.endswith("1"):
                    default_store_index = i
                    break
                
            # Look for "PRODUCE" in the families list
            for good_family in ["PRODUCE", "FROZEN FOODS", "GROCERY I", "DAIRY"]:
                if good_family in families:
                    default_family_index = families.index(good_family)
                    break
        
        with col1:
            store_nbr = st.selectbox("Store Number", stores, index=default_store_index)
        
        with col2:
            family = st.selectbox("Product Family", families, index=default_family_index)
        
        with col3:
            onpromotion = st.checkbox("On Promotion")
        
        date = st.date_input("Prediction Date", datetime.now().date() + timedelta(days=1))
        
        submitted = st.form_submit_button("Generate Prediction")
    
    # Process form submission
    if submitted:
        if "token" in st.session_state:
            with st.spinner("Generating prediction..."):
                # Extract store number from string (if needed)
                store_val = 1  # Default value
                
                try:
                    if isinstance(store_nbr, str) and "store" in store_nbr.lower():
                        # Format is like "Store 1" - extract the number
                        parts = store_nbr.split()
                        if len(parts) > 1 and parts[1].isdigit():
                            store_val = int(parts[1])
                    elif isinstance(store_nbr, (int, float)):
                        store_val = int(store_nbr)
                except (ValueError, TypeError):
                    # If conversion fails, use store 1
                    store_val = 1
                
                # Make prediction request
                prediction = get_prediction(
                    st.session_state.token,
                    store_val,
                    family,
                    onpromotion,
                    date.strftime("%Y-%m-%d")
                )
                
                if prediction:
                    # Show prediction results in visually appealing card
                    # Check if this is a fallback prediction
                    is_fallback = prediction.get('is_fallback', False)
                    saved_to_db = prediction.get('saved_to_db', False)
                    
                    # Format prediction
                    st.markdown("""
                    <div class="prediction-card">
                        <div class="prediction-header">
                            <h3 style="color: #4fd1c5; margin: 0; flex-grow: 1;">Prediction Results</h3>
                        </div>
                    """, unsafe_allow_html=True)
                    
                    # Par√¢metros
                    st.markdown(f"""
                    <div style="margin-bottom: 15px;">
                        <div style="display: inline-block; background-color: #1a1a1a; padding: 5px 10px; border-radius: 4px; margin-right: 10px; margin-bottom: 10px;">
                            <span style="color: #888; font-size: 0.75em;">STORE</span><br>
                            <span style="color: #fff;">{store_nbr}</span>
                        </div>
                        <div style="display: inline-block; background-color: #1a1a1a; padding: 5px 10px; border-radius: 4px; margin-right: 10px; margin-bottom: 10px;">
                            <span style="color: #888; font-size: 0.75em;">PRODUCT</span><br>
                            <span style="color: #fff;">{family}</span>
                        </div>
                        <div style="display: inline-block; background-color: #1a1a1a; padding: 5px 10px; border-radius: 4px; margin-right: 10px; margin-bottom: 10px;">
                            <span style="color: #888; font-size: 0.75em;">DATE</span><br>
                            <span style="color: #fff;">{date.strftime("%Y-%m-%d")}</span>
                        </div>
                        <div style="display: inline-block; background-color: #1a1a1a; padding: 5px 10px; border-radius: 4px; margin-bottom: 10px;">
                            <span style="color: #888; font-size: 0.75em;">PROMOTION</span><br>
                            <span style="color: #fff;">{"Yes" if onpromotion else "No"}</span>
                        </div>
                    </div>
                    """, unsafe_allow_html=True)
                    
                    # Prediction result
                    prediction_value = None
                    if 'prediction' in prediction:
                        prediction_value = prediction['prediction']
                    elif 'predicted_sales' in prediction:
                        prediction_value = prediction['predicted_sales']
                    else:
                        st.error("Prediction data format is invalid. Missing prediction value.")
                        prediction_value = 0
                    
                    if is_fallback:
                        message = prediction.get('message', 'WARNING: Using simulated prediction (fallback)')
                        st.warning(message, icon="‚ö†Ô∏è")
                        
                        st.markdown(f"""
                        <div style="background-color: rgba(255, 209, 102, 0.1); border: 1px solid rgba(255, 209, 102, 0.3); border-radius: 8px; padding: 15px; text-align: center;">
                            <h3 style="color: #FFD166; margin: 0 0 5px 0;">Predicted Sales (SIMULATED)</h3>
                            <p style="font-size: 32px; font-weight: bold; margin: 0; color: #FFD166;">${prediction_value:.2f}</p>
                        </div>
                        """, unsafe_allow_html=True)
                        
                        # Show error details if debug is enabled
                        if enable_debug and 'error' in prediction:
                            st.error(f"Model Error: {prediction['error']}")
                    else:
                        st.markdown(f"""
                        <div class="real-prediction" style="text-align: center;">
                            <div style="display: flex; align-items: center; justify-content: center; margin-bottom: 5px;">
                                <h3 style="color: #06D6A0; margin: 0;">Predicted Sales</h3>
                                <span style="background-color: rgba(6, 214, 160, 0.2); color: #06D6A0; padding: 2px 8px; border-radius: 12px; font-size: 12px; font-weight: bold; margin-left: 10px;">REAL MODEL</span>
                            </div>
                            <p style="font-size: 42px; font-weight: bold; margin: 10px 0; color: #06D6A0;">${prediction_value:.2f}</p>
                            <p style="font-size: 14px; margin: 0; opacity: 0.7;">Generated on {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}</p>
                        </div>
                        """, unsafe_allow_html=True)
                        
                        # Show if prediction was saved to database
                        if enable_debug:
                            if saved_to_db:
                                st.success("‚úÖ Prediction saved to database")
                            else:
                                st.warning("‚ö†Ô∏è Prediction not saved to database")
                    
                    # Show raw prediction data in debug mode
                    if enable_debug:
                        with st.expander("Raw Prediction Data"):
                            st.json(prediction)
                    
                    # Save prediction ID for explanation
                    prediction_id = prediction.get('prediction_id', f"{store_val}-{family}-{date}")
                    
                    # Get explanation
                    with st.spinner("Generating explanation..."):
                        try:
                            explanation = get_explanation(
                                st.session_state.token,
                                prediction_id,
                                store_val,
                                family,
                                onpromotion,
                                date.strftime("%Y-%m-%d")
                            )
                            
                            if explanation:
                                st.markdown("""
                                <div class="prediction-header" style="margin-top: 30px; border-bottom: 1px solid #333; padding-bottom: 10px;">
                                    <h3 style="color: #4fd1c5; margin: 0; flex-grow: 1;">Prediction Explanation</h3>
                                </div>
                                """, unsafe_allow_html=True)
                                
                                # Check for explanation message that might indicate it's a fallback
                                exp_message = explanation.get("message", "")
                                if "error" in exp_message.lower() or "not available" in exp_message.lower():
                                    st.warning(exp_message, icon="‚ö†Ô∏è")
                                
                                # Display feature contributions
                                feature_contributions = explanation.get("feature_contributions", [])
                                if feature_contributions:
                                    # Create dataframe for chart
                                    feat_df = pd.DataFrame(feature_contributions)
                                    
                                    # Sort by absolute contribution
                                    feat_df['abs_contribution'] = feat_df['contribution'].abs()
                                    feat_df = feat_df.sort_values('abs_contribution', ascending=False).head(10)
                                    
                                    # Create waterfall chart
                                    fig = go.Figure(go.Waterfall(
                                        name="Features",
                                        orientation="h",
                                        measure=["relative"] * len(feat_df),
                                        y=feat_df['feature'],
                                        x=feat_df['contribution'],
                                        connector={"line": {"color": "rgb(63, 63, 63)"}},
                                        decreasing={"marker": {"color": "rgba(255, 50, 50, 0.8)"}},
                                        increasing={"marker": {"color": "rgba(50, 200, 50, 0.8)"}},
                                        text=feat_df['value'].round(2)
                                    ))
                                    
                                    fig.update_layout(
                                        title="Feature Contributions to Prediction",
                                        showlegend=False,
                                        template="plotly_dark",
                                        height=500
                                    )
                                    
                                    st.plotly_chart(fig, use_container_width=True)
                                    
                                    # Adicionar explica√ß√£o sobre as features principais
                                    top_features = feat_df.head(3)
                                    if not top_features.empty:
                                        st.markdown("""
                                        <div style="background-color: #262730; border-radius: 8px; padding: 15px; margin-top: 15px;">
                                            <h4 style="color: #FFD166; margin-top: 0;">Key Factors Influencing This Prediction</h4>
                                        """, unsafe_allow_html=True)
                                        
                                        for _, row in top_features.iterrows():
                                            direction = "increased" if row['contribution'] > 0 else "decreased"
                                            magnitude = abs(row['contribution'])
                                            color = "#06D6A0" if row['contribution'] > 0 else "#FF4B4B"
                                            
                                            st.markdown(f"""
                                            <div style="margin-bottom: 10px; padding-bottom: 10px; border-bottom: 1px solid #333;">
                                                <span style="color: {color}; font-weight: bold;">{row['feature']}</span>: 
                                                <span>Value of <strong>{row['value']:.2f}</strong> {direction} the prediction by <strong>${magnitude:.2f}</strong></span>
                                            </div>
                                            """, unsafe_allow_html=True)
                                        
                                        st.markdown("</div>", unsafe_allow_html=True)
                                else:
                                    st.warning("Explanation available but no feature contributions found.")
                                    
                                # Show raw explanation in debug mode
                                if enable_debug:
                                    with st.expander("Raw Explanation Data"):
                                        st.json(explanation)
                            else:
                                st.warning("Unable to generate explanation for this prediction.")
                        except Exception as exp_error:
                            st.error(f"Error generating explanation: {str(exp_error)}")
                            st.warning("Unable to generate explanation for this prediction. Model may not support explainability.")
                            
                    st.markdown("</div>", unsafe_allow_html=True)
                    
                    # Sugest√µes de a√ß√£o com base na previs√£o
                    if prediction_value is not None:
                        st.markdown("""
                        <div class="prediction-card" style="border-left: 3px solid #FFD166;">
                            <div class="prediction-header">
                                <h3 style="color: #FFD166; margin: 0; flex-grow: 1;">Recommended Actions</h3>
                            </div>
                            
                            <div style="display: flex; flex-wrap: wrap; gap: 15px; margin-top: 15px;">
                        """, unsafe_allow_html=True)
                        
                        # Determinar recomenda√ß√µes com base no valor da previs√£o
                        is_high_value = prediction_value > 50
                        is_promotion = onpromotion
                        
                        if is_high_value and not is_promotion:
                            st.markdown("""
                            <div style="flex: 1; min-width: 200px; background-color: rgba(6, 214, 160, 0.1); border-radius: 8px; padding: 15px; border: 1px solid rgba(6, 214, 160, 0.3);">
                                <h4 style="color: #06D6A0; margin-top: 0;">Consider Promotion</h4>
                                <p style="margin-bottom: 0;">High predicted sales volume indicates strong demand. Consider running a promotion to maximize revenue.</p>
                            </div>
                            """, unsafe_allow_html=True)
                        elif is_high_value and is_promotion:
                            st.markdown("""
                            <div style="flex: 1; min-width: 200px; background-color: rgba(6, 214, 160, 0.1); border-radius: 8px; padding: 15px; border: 1px solid rgba(6, 214, 160, 0.3);">
                                <h4 style="color: #06D6A0; margin-top: 0;">Increase Inventory</h4>
                                <p style="margin-bottom: 0;">High sales expected with promotion in effect. Ensure adequate inventory to meet increased demand.</p>
                            </div>
                            """, unsafe_allow_html=True)
                        elif not is_high_value and not is_promotion:
                            st.markdown("""
                            <div style="flex: 1; min-width: 200px; background-color: rgba(255, 209, 102, 0.1); border-radius: 8px; padding: 15px; border: 1px solid rgba(255, 209, 102, 0.3);">
                                <h4 style="color: #FFD166; margin-top: 0;">Optimize Inventory</h4>
                                <p style="margin-bottom: 0;">Low predicted sales volume. Consider reducing stock levels to minimize holding costs.</p>
                            </div>
                            """, unsafe_allow_html=True)
                        else:
                            st.markdown("""
                            <div style="flex: 1; min-width: 200px; background-color: rgba(255, 209, 102, 0.1); border-radius: 8px; padding: 15px; border: 1px solid rgba(255, 209, 102, 0.3);">
                                <h4 style="color: #FFD166; margin-top: 0;">Review Promotion Strategy</h4>
                                <p style="margin-bottom: 0;">Low sales despite promotion. Consider revising promotion strategy or product placement.</p>
                            </div>
                            """, unsafe_allow_html=True)
                        
                        # Decis√£o de compra
                        st.markdown("""
                        <div style="flex: 1; min-width: 200px; background-color: rgba(66, 153, 225, 0.1); border-radius: 8px; padding: 15px; border: 1px solid rgba(66, 153, 225, 0.3);">
                            <h4 style="color: #4299E1; margin-top: 0;">Purchasing Decision</h4>
                            <p style="margin-bottom: 0;">Optimize order quantity based on the predicted sales of ${:.2f} units per day.</p>
                        </div>
                        """.format(prediction_value), unsafe_allow_html=True)
                        
                        st.markdown("""
                            </div>
                        </div>
                        """, unsafe_allow_html=True)
        else:
            st.error("You must login first to make predictions.")
            st.markdown("""
            <div style="background-color: #1E1E1E; padding: 15px; border-radius: 10px; margin-top: 20px; border-left: 3px solid #FF4B4B;">
                <h4 style="color: #FF4B4B; margin-top: 0;">Authentication Required</h4>
                <p>Please login using the sidebar to access the prediction functionality.</p>
            </div>
            """, unsafe_allow_html=True)

def render_model_insights():
    """
    Render the model insights page.
    """
    # Adicionar estilo para a p√°gina de insights
    st.markdown("""
    <style>
    .insight-card {
        background-color: #1E1E1E;
        border-radius: 10px;
        padding: 20px;
        margin-bottom: 20px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        border-left: 3px solid #4fd1c5;
        transition: all 0.3s ease;
    }
    
    .insight-card:hover {
        box-shadow: 0 8px 20px rgba(0,0,0,0.25);
        transform: translateY(-2px);
    }
    
    .insight-header {
        display: flex;
        align-items: center;
        margin-bottom: 15px;
        border-bottom: 1px solid #333;
        padding-bottom: 10px;
    }
    
    .metric-card {
        background-color: #262730;
        border-radius: 8px;
        padding: 15px;
        text-align: center;
        transition: transform 0.2s ease;
    }
    
    .metric-card:hover {
        transform: translateY(-3px);
    }
    
    .metric-value {
        font-size: 24px;
        font-weight: bold;
        margin: 5px 0;
    }
    
    .metric-label {
        font-size: 12px;
        color: #aaa;
        text-transform: uppercase;
        letter-spacing: 1px;
    }
    
    .gradient-text {
        background: linear-gradient(90deg, #4fd1c5, #4299e1);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        display: inline-block;
    }
    
    .badge {
        display: inline-block;
        padding: 3px 8px;
        border-radius: 12px;
        font-size: 10px;
        font-weight: bold;
        text-transform: uppercase;
        letter-spacing: 1px;
    }
    
    .badge-good {
        background-color: rgba(6, 214, 160, 0.2);
        color: #06D6A0;
    }
    
    .badge-warning {
        background-color: rgba(255, 209, 102, 0.2);
        color: #FFD166;
    }
    
    .badge-danger {
        background-color: rgba(255, 75, 75, 0.2);
        color: #FF4B4B;
    }
    </style>
    """, unsafe_allow_html=True)
    
    # T√≠tulo com gradiente
    st.markdown("""
    <h1 class="gradient-text" style="font-size: 36px; margin-bottom: 20px;">Model Insights & Performance</h1>
    """, unsafe_allow_html=True)
    
    # Descri√ß√£o moderna
    st.markdown("""
    <div class="insight-card">
        <div class="insight-header">
            <h3 style="color: #4fd1c5; margin: 0; flex-grow: 1;">Performance Analytics</h3>
            <span class="badge badge-good">ML MONITORING</span>
        </div>
        <p>Explore detailed model performance metrics, feature importance, and drift analysis to understand how our forecasting models are performing and identify areas for improvement.</p>
    </div>
    """, unsafe_allow_html=True)
    
    # Selecionar modelo
    if "token" not in st.session_state:
        st.warning("Please login to view model insights.")
        st.markdown("""
        <div style="background-color: #1E1E1E; padding: 15px; border-radius: 10px; margin-top: 20px; border-left: 3px solid #FF4B4B;">
            <h4 style="color: #FF4B4B; margin-top: 0;">Authentication Required</h4>
            <p>Please login using the sidebar to access the model insights functionality.</p>
        </div>
        """, unsafe_allow_html=True)
        return
    
    # Mostrar modelos dispon√≠veis de forma mais atraente
    st.markdown("""
    <div class="insight-card" style="border-left: 3px solid #FFD166;">
        <div class="insight-header">
            <h3 style="color: #FFD166; margin: 0;">Available Models</h3>
        </div>
    """, unsafe_allow_html=True)
    
    # Modelos dispon√≠veis
    models = ["LightGBM (Production)", "XGBoost (Staging)", "Prophet (Development)"]
    
    # Cart√µes para cada modelo
    cols = st.columns(len(models))
    for i, model in enumerate(models):
        with cols[i]:
            if model == "LightGBM (Production)":
                badge = '<span class="badge badge-good">PRODUCTION</span>'
                border = "#06D6A0"
            elif model == "XGBoost (Staging)":
                badge = '<span class="badge badge-warning">STAGING</span>'
                border = "#FFD166"
            else:
                badge = '<span class="badge badge-danger">DEV</span>'
                border = "#FF4B4B"
                
            st.markdown(f"""
            <div style="background-color: #262730; border-radius: 8px; padding: 15px; text-align: center; border-left: 3px solid {border}; cursor: pointer;" 
                 onclick="alert('Select this model')">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                    <h4 style="margin: 0; color: #fff;">{model.split(' ')[0]}</h4>
                    {badge}
                </div>
                <p style="font-size: 12px; opacity: 0.7; margin: 0; text-align: left;">{model.split(' ')[1].replace('(', '').replace(')', '')}</p>
            </div>
            """, unsafe_allow_html=True)
    
    st.markdown("</div>", unsafe_allow_html=True)
    
    # Continuar com o resto do c√≥digo
    st.markdown("""
    <div class="insight-card">
        <div class="insight-header">
            <h3 style="color: #4fd1c5; margin: 0;">Model Selection</h3>
        </div>
    """, unsafe_allow_html=True)
    
    model_name = st.selectbox("Select Model to Analyze", 
                            ["LightGBM (Production)", "XGBoost (Staging)", "Prophet (Development)"],
                            index=0)
    
    # Time period para an√°lise
    col1, col2 = st.columns(2)
    with col1:
        days = st.slider("Historical Period (days)", min_value=7, max_value=90, value=30, step=7)
    with col2:
        threshold = st.slider("Performance Threshold (%)", min_value=50, max_value=95, value=75, step=5)
    
    st.markdown("</div>", unsafe_allow_html=True)
    
    # Load model metrics
    with st.spinner("Loading model performance metrics..."):
        try:
            metrics = get_model_metrics(st.session_state.token, model_name)
            
            if metrics:
                # Overall performance 
                st.markdown("""
                <div class="insight-card">
                    <div class="insight-header">
                        <h3 style="color: #4fd1c5; margin: 0;">Performance Overview</h3>
                    </div>
                    <div style="display: flex; flex-wrap: wrap; gap: 15px;">
                """, unsafe_allow_html=True)
                
                # Determine color based on value
                def get_metric_color(value, metric_type):
                    if metric_type == "accuracy" or metric_type == "r2":
                        if value >= 0.8:
                            return "#06D6A0"  # Good (green)
                        elif value >= 0.6:
                            return "#FFD166"  # Warning (yellow)
                        else:
                            return "#FF4B4B"  # Bad (red)
                    elif metric_type == "rmse" or metric_type == "mae":
                        if value <= 10:
                            return "#06D6A0"  # Good (green)
                        elif value <= 25:
                            return "#FFD166"  # Warning (yellow)
                        else:
                            return "#FF4B4B"  # Bad (red)
                    else:
                        return "#4fd1c5"  # Default
                
                # Create metric cards with appropriate colors
                metric_data = [
                    {"name": "Accuracy", "value": metrics.get("accuracy", 0) * 100, "format": "%.1f%%", "type": "accuracy"},
                    {"name": "RMSE", "value": metrics.get("rmse", 0), "format": "%.2f", "type": "rmse"},
                    {"name": "MAE", "value": metrics.get("mae", 0), "format": "%.2f", "type": "mae"},
                    {"name": "R¬≤ Score", "value": metrics.get("r2", 0), "format": "%.3f", "type": "r2"}
                ]
                
                for metric in metric_data:
                    color = get_metric_color(metric["value"] / 100 if metric["name"] == "Accuracy" else metric["value"], metric["type"])
                    
                    st.markdown(f"""
                    <div style="flex: 1; min-width: 150px;">
                        <div class="metric-card" style="border-top: 3px solid {color};">
                            <div class="metric-label">{metric["name"]}</div>
                            <div class="metric-value" style="color: {color};">{metric["format"] % metric["value"]}</div>
                        </div>
                    </div>
                    """, unsafe_allow_html=True)
                
                st.markdown("""
                    </div>
                </div>
                """, unsafe_allow_html=True)
                
                # Feature importance
                with st.spinner("Loading feature importance..."):
                    feature_importance = get_feature_importance(st.session_state.token, model_name)
                    
                    if feature_importance and isinstance(feature_importance, list):
                        # Organize data for visualization
                        feature_df = pd.DataFrame(feature_importance)
                        
                        if not feature_df.empty and "feature" in feature_df.columns and "importance" in feature_df.columns:
                            # Sort by importance
                            feature_df = feature_df.sort_values("importance", ascending=False).head(10)
                            
                            st.markdown("""
                            <div class="insight-card">
                                <div class="insight-header">
                                    <h3 style="color: #4fd1c5; margin: 0;">Feature Importance</h3>
                                </div>
                            """, unsafe_allow_html=True)
                            
                            # Create animated bar chart
                            fig = px.bar(
                                feature_df,
                                x="importance",
                                y="feature",
                                orientation="h",
                                color="importance",
                                color_continuous_scale=["#4299e1", "#4fd1c5", "#06D6A0"],
                                title="Top 10 Most Important Features"
                            )
                            
                            fig.update_layout(
                                template="plotly_dark",
                                xaxis_title="Relative Importance",
                                yaxis_title="",
                                coloraxis_showscale=False,
                                height=500
                            )
                            
                            st.plotly_chart(fig, use_container_width=True)
                            
                            # Add insights about top features
                            top_features = feature_df.head(3)
                            
                            st.markdown("""
                            <div style="background-color: #262730; border-radius: 8px; padding: 15px; margin-top: 10px;">
                                <h4 style="color: #FFD166; margin-top: 0;">Key Findings</h4>
                                <ul style="margin-bottom: 0; padding-left: 20px;">
                            """, unsafe_allow_html=True)
                            
                            for _, row in top_features.iterrows():
                                st.markdown(f"""
                                <li style="margin-bottom: 8px;"><strong style="color: #4fd1c5;">{row['feature']}</strong> is the most significant feature, accounting for <strong>{row['importance']:.1f}%</strong> of the model's predictive power.</li>
                                """, unsafe_allow_html=True)
                            
                            st.markdown("""
                                </ul>
                            </div>
                            """, unsafe_allow_html=True)
                            
                            st.markdown("</div>", unsafe_allow_html=True)
                    else:
                        st.warning("Feature importance data is not available for this model.")
                
                # Model drift analysis
                with st.spinner("Analyzing model drift..."):
                    drift_data = get_model_drift(st.session_state.token, model_name, days)
                    
                    if drift_data and isinstance(drift_data, dict) and "dates" in drift_data and "accuracy" in drift_data:
                        drift_df = pd.DataFrame({
                            "date": drift_data["dates"],
                            "accuracy": drift_data["accuracy"]
                        })
                        
                        st.markdown("""
                        <div class="insight-card">
                            <div class="insight-header">
                                <h3 style="color: #4fd1c5; margin: 0;">Model Drift Analysis</h3>
                            </div>
                        """, unsafe_allow_html=True)
                        
                        # Create line chart for model drift
                        fig = px.line(
                            drift_df,
                            x="date",
                            y="accuracy",
                            markers=True,
                            title=f"Model Accuracy Over Time (Last {days} Days)",
                            color_discrete_sequence=["#4fd1c5"]
                        )
                        
                        # Add threshold line
                        fig.add_shape(
                            type="line",
                            x0=drift_df["date"].min(),
                            x1=drift_df["date"].max(),
                            y0=threshold / 100,
                            y1=threshold / 100,
                            line=dict(color="#FF4B4B", width=2, dash="dash")
                        )
                        
                        # Add annotation for threshold
                        fig.add_annotation(
                            x=drift_df["date"].max(),
                            y=threshold / 100,
                            text=f"Threshold ({threshold}%)",
                            showarrow=False,
                            yshift=10,
                            font=dict(color="#FF4B4B")
                        )
                        
                        fig.update_layout(
                            template="plotly_dark",
                            xaxis_title="Date",
                            yaxis_title="Accuracy",
                            yaxis=dict(tickformat=".0%"),
                            height=400
                        )
                        
                        st.plotly_chart(fig, use_container_width=True)
                        
                        # Calculate drift metrics
                        current_accuracy = drift_df["accuracy"].iloc[-1] if not drift_df.empty else 0
                        avg_accuracy = drift_df["accuracy"].mean() if not drift_df.empty else 0
                        min_accuracy = drift_df["accuracy"].min() if not drift_df.empty else 0
                        
                        drift_analysis = ""
                        drift_status = ""
                        
                        if current_accuracy < threshold / 100:
                            drift_status = '<span class="badge badge-danger">CRITICAL</span>'
                            drift_analysis = "Model is currently performing below the acceptable threshold. Retraining is required."
                        elif current_accuracy < avg_accuracy * 0.95:
                            drift_status = '<span class="badge badge-warning">DRIFT DETECTED</span>'
                            drift_analysis = "Model is showing signs of drift. Consider retraining soon."
                        else:
                            drift_status = '<span class="badge badge-good">STABLE</span>'
                            drift_analysis = "Model is performing stably. No immediate action required."
                        
                        st.markdown(f"""
                        <div style="background-color: #262730; border-radius: 8px; padding: 15px; margin-top: 10px;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                <h4 style="color: #FFD166; margin: 0;">Drift Status</h4>
                                {drift_status}
                            </div>
                            <p style="margin-bottom: 15px;">{drift_analysis}</p>
                            
                            <div style="display: flex; flex-wrap: wrap; gap: 15px;">
                                <div style="flex: 1; min-width: 120px; background-color: #1a1a1a; padding: 10px; border-radius: 8px; text-align: center;">
                                    <div style="font-size: 11px; text-transform: uppercase; color: #888;">Current</div>
                                    <div style="font-size: 18px; font-weight: bold; color: #4fd1c5;">{current_accuracy:.1%}</div>
                                </div>
                                <div style="flex: 1; min-width: 120px; background-color: #1a1a1a; padding: 10px; border-radius: 8px; text-align: center;">
                                    <div style="font-size: 11px; text-transform: uppercase; color: #888;">Average</div>
                                    <div style="font-size: 18px; font-weight: bold; color: #4fd1c5;">{avg_accuracy:.1%}</div>
                                </div>
                                <div style="flex: 1; min-width: 120px; background-color: #1a1a1a; padding: 10px; border-radius: 8px; text-align: center;">
                                    <div style="font-size: 11px; text-transform: uppercase; color: #888;">Minimum</div>
                                    <div style="font-size: 18px; font-weight: bold; color: #4fd1c5;">{min_accuracy:.1%}</div>
                                </div>
                            </div>
                        </div>
                        """, unsafe_allow_html=True)
                        
                        st.markdown("</div>", unsafe_allow_html=True)
                    else:
                        st.warning("Model drift data is not available for this model and time period.")
            else:
                st.error("Failed to fetch model metrics. Please try again later.")
        except Exception as e:
            st.error(f"Error fetching model insights: {str(e)}")
            st.markdown("""
            <div style="background-color: #1E1E1E; padding: 15px; border-radius: 10px; margin-top: 20px; border-left: 3px solid #FF4B4B;">
                <h4 style="color: #FF4B4B; margin-top: 0;">Error Loading Insights</h4>
                <p>There was a problem loading the model insights. This could be due to API unavailability or mock data limitations.</p>
            </div>
            """, unsafe_allow_html=True)

def render_settings():
    """
    Render the settings page.
    """
    st.title("Settings")
    
    st.markdown("""
    Configure your dashboard preferences and API connections.
    """)
    
    # Tabs for different settings
    tab1, tab2, tab3 = st.tabs(["Dashboard", "API Connection", "Notifications"])
    
    with tab1:
        st.subheader("Dashboard Settings")
        
        # Theme selection
        st.selectbox(
            "Theme", 
            ["Light", "Dark", "Auto"],
            index=0
        )
        
        # Default views
        st.multiselect(
            "Default Dashboard Widgets",
            ["Sales Trends", "Store Comparison", "Product Performance", "Forecast Accuracy", "Alerts"],
            default=["Sales Trends", "Store Comparison", "Product Performance"]
        )
        
        # Chart preferences
        st.radio(
            "Default Chart Type",
            ["Line", "Bar", "Area"],
            horizontal=True
        )
    
    with tab2:
        st.subheader("API Connection Settings")
        
        # API URL
        current_api = st.text_input("API URL", API_URL)
        
        # MLflow URL
        current_mlflow = st.text_input("MLflow URL", MLFLOW_URL)
        
        # Test connection button
        if st.button("Test Connection"):
            health = get_health()
            if health["status"] == "healthy":
                st.success("Connection successful! API is healthy.")
            else:
                st.error(f"Connection failed: {health.get('message', 'Unknown error')}")
    
    with tab3:
        st.subheader("Notification Settings")
        
        # Email notifications
        st.checkbox("Enable Email Notifications", value=True)
        
        st.text_input("Email Address", placeholder="your.email@example.com")
        
        # Notification preferences
        st.multiselect(
            "Notification Types",
            ["Model Drift Alerts", "Prediction Errors", "System Status", "Weekly Reports"],
            default=["Model Drift Alerts", "System Status"]
        )
        
        # Notification frequency
        st.select_slider(
            "Notification Frequency",
            options=["Immediate", "Hourly", "Daily", "Weekly"]
        )

def main():
    """
    Main function to run the dashboard.
    """
    # Initialize session state
    if "page" not in st.session_state:
        st.session_state.page = "Dashboard"
    
    # Render sidebar
    render_sidebar()
    
    # Render selected page
    if "token" not in st.session_state:
        # Banner superior personalizado em vez do warning padr√£o
        st.markdown("""
        <div class="custom-top-banner">
            <div class="banner-icon">‚ö†Ô∏è</div>
            <div class="banner-text">Please login to view the complete dashboard. Use the sidebar to login.</div>
        </div>
        """, unsafe_allow_html=True)
        
        # Substituir o banner de aviso por um mais vis√≠vel e atraente
        st.markdown("""
        <div class="login-banner">
            <div class="login-banner-icon">üîí</div>
            <div class="login-banner-text">Please login using the sidebar to access the complete dashboard.</div>
        </div>
        """, unsafe_allow_html=True)
        
        # Custom CSS for gradient backgrounds and card animations
        st.markdown("""
        <style>
        .gradient-header {
            background: linear-gradient(90deg, #4CAF50 0%, #3e8e41 100%);
            padding: 20px;
            border-radius: 10px;
            color: white;
            margin-bottom: 30px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.15);
        }
        
        .dashboard-card {
            background-color: #1e1e1e;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 15px;
            border-left: 3px solid #4CAF50;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        
        .dashboard-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 20px rgba(0,0,0,0.2);
        }
        
        .feature-icon {
            font-size: 28px;
            margin-bottom: 10px;
            color: #4CAF50;
        }
        
        .stats-card {
            background-color: #1e1e1e;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 10px;
            text-align: center;
            border-bottom: 3px solid #4CAF50;
        }
        
        .stats-value {
            font-size: 24px;
            font-weight: bold;
            color: #4CAF50;
            margin: 5px 0;
        }
        
        .stats-label {
            font-size: 12px;
            color: #cccccc;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .badge {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 10px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .badge-ml {
            background-color: rgba(76, 175, 80, 0.2);
            color: #4CAF50;
        }
        
        .badge-api {
            background-color: rgba(76, 175, 80, 0.2);
            color: #4CAF50;
        }
        
        .badge-viz {
            background-color: rgba(76, 175, 80, 0.2);
            color: #4CAF50;
        }
        </style>
        """, unsafe_allow_html=True)
        
        # Modern Design Header
        st.markdown("""
        <div style="position: relative; padding: 50px 30px; overflow: hidden; margin: 20px 0 40px 0; border-radius: 15px; background-color: rgba(30, 30, 46, 0.3);">
            <!-- Gradient Circles Background -->
            <div style="position: absolute; width: 300px; height: 300px; border-radius: 50%; top: -120px; right: -80px; 
                background: linear-gradient(135deg, #4CAF50 0%, rgba(30, 30, 46, 0) 70%); opacity: 0.6; z-index: -1;"></div>
            <div style="position: absolute; width: 250px; height: 250px; border-radius: 50%; bottom: -100px; left: -80px; 
                background: linear-gradient(225deg, #3e8e41 0%, rgba(30, 30, 46, 0) 70%); opacity: 0.5; z-index: -1;"></div>
            
            <!-- Main Content -->
            <div>
                <p style="text-transform: uppercase; letter-spacing: 3px; font-size: 14px; color: #4CAF50; margin-bottom: 5px;">Sales Analytics</p>
                <h1 style="font-size: 52px; font-weight: 800; margin: 5px 0 20px 0; letter-spacing: -1px;">Store<br>Forecasting</h1>
                <p style="color: #cccccc; margin-bottom: 25px; font-size: 17px; max-width: 500px; line-height: 1.5;">
                    The intelligent analytics platform designed with precision and performance for retail sales optimization.
                </p>
                <div style="display: inline-block; background: linear-gradient(90deg, #4CAF50, #3e8e41); color: #fff; 
                    padding: 12px 25px; border-radius: 30px; font-weight: 600; font-size: 15px;">
                    Login to Dashboard
                </div>
            </div>
        </div>
        """, unsafe_allow_html=True)
        
        # Feature Cards
        st.markdown("""
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px; margin-top: 30px;">
            <div class="dashboard-card">
                <div class="feature-icon">üìä</div>
                <h3 style="color: #4CAF50; margin-top: 0;">Sales Forecasting</h3>
                <p style="color: #aaa;">Predict future sales with ML-powered forecasting models that adapt to your business patterns.</p>
                <div class="badge badge-ml">Machine Learning</div>
            </div>
            
            <div class="dashboard-card">
                <div class="feature-icon">üîç</div>
                <h3 style="color: #4CAF50; margin-top: 0;">Data Analysis</h3>
                <p style="color: #aaa;">Drill down into your sales data to uncover insights and identify growth opportunities.</p>
                <div class="badge badge-viz">Visualization</div>
            </div>
            
            <div class="dashboard-card">
                <div class="feature-icon">üöÄ</div>
                <h3 style="color: #4CAF50; margin-top: 0;">Performance Tracking</h3>
                <p style="color: #aaa;">Monitor store and product performance metrics in real-time with interactive dashboards.</p>
                <div class="badge badge-api">API Integration</div>
            </div>
        </div>
        """, unsafe_allow_html=True)
    else:
        # Render the appropriate page
        if st.session_state.page == "Dashboard":
            display_dashboard()
        elif st.session_state.page == "Predictions":
            render_predictions()
        elif st.session_state.page == "Model Insights":
            render_model_insights()
        elif st.session_state.page == "Settings":
            render_settings()

if __name__ == "__main__":
    main() # timestamp: 1746712458.8450198